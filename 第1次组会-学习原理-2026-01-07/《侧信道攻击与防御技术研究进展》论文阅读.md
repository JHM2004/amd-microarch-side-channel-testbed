## 《侧信道攻击与防御技术研究进展》

**论文链接：**http://cjc.ict.ac.cn/online/onlinepaper/wyj-2023112143101.pdf 

**摘要：**侧信道攻击利用密码实现的**物理泄露**而不是理论弱点来恢复密钥，对密码系统的安全实现有严重的现实威胁. 密码设备运行时所产生的**能量、电磁、缓存和故障输出等侧信息均可能导致密钥信息泄漏**，攻击者通过分析侧信息中与密钥相关的特征点来获取密钥信息. 为了应对侧信道攻击，侧信道防御技术和抗泄漏密码学也成为研究的热点问题. 前者的总体思路在于消除侧信息泄漏或者消除秘密信息与所泄漏侧信息之间的相关性，而后者旨在准确量化密码系统执行过程中的侧信息泄漏，进而构造具有抗泄漏安全性的密码方案. 本文系统地介绍了侧信道攻击与防御技术发展：首先，剖析了**时序攻击、能量分析攻击、缓存攻击和故障攻击的基本原理、攻击方法、应用场景和发展现状，并提炼出每一类攻击的通用模型**；其次，概括出侧信道防御技术的本质特征，并分析了**侧信道防御技术的基本原理、安全模型和应用场景；**之后总结了抗泄漏密码学的基本原理与发展现状，梳理了**典型的抗泄漏密码方案**；最后分析了现有研究工作中存在的问题，并对未来的研究方向进行了展望.

**关键词** ：侧信道攻击；侧信道防御；抗泄漏密码学；能量分析攻击；缓存攻击；故障攻击

---

### 1. 时序攻击

```cpp
平方乘算法
输入：基数 b，模数 m，指数 e = (e_{n-1}···e_0)
输出：b^e mod m

r = 1  // 初始化结果变量  
for i = n-1 downto 0 do  // 遍历指数二进制位（从最高位到最低位）  
   // 【时序攻击泄漏点1】：循环次数 = 指数二进制位数，暴露密钥长度信息 
    if e_i = 1 then  // 若当前位为1，执行乘法操作  
    // 【时序攻击泄漏点2】：条件分支导致执行路径差异，是密钥位信息泄漏的核心
    // 攻击利用：乘法操作（第4行）比单纯平方操作耗时更长，攻击者可通过测量时间差推断e_i是否为1  
        r = r · b mod m  // 乘法步骤：密钥相关操作，时序泄漏关键节点  
    end if  
    r = r² mod m  // 平方操作：无论e_i是否为1均执行，耗时相对稳定  
    // 攻击案例：Brumley等人利用Montgomery模约化步骤的额外模简化时间差，攻击OpenSSL的RSA实现
end for  
return r  // 输出模幂结果
```

**1.1 泄漏点**：

- 第2行循环次数直接对应指数 e e e 的二进制位数，攻击者可通过多次测量推断密钥长度（如RSA密钥的2048位/4096位）。
- 第3-5行的条件分支（`if e_i=1`）导致乘法操作（第4行）的执行次数与密钥位中1的数量正相关，执行时间差异可被精确测量（如本地网络环境下，Billy等人通过SSL握手时间恢复OpenSSL密钥，文档2.1节）。

**1.2 典型攻击场景**：

- **本地攻击**：同一物理机/虚拟机内，攻击者通过高精度计时（如`rdtsc`指令）测量单次加密时间，直接关联密钥位（文档中Billy的本地实验成功率>90%）。
- **远程攻击**：通过WAN/无线网络，攻击者需克服网络延迟噪声，采用“多数投票”法统计多次加密时间差异，推断密钥位（文档中Billy的WAN环境实验需>1000次样本）。

- **防御关联**：
   该算法的非恒定时间特性是时序攻击的根源，**Montgomery阶梯标量乘法** 通过移除条件分支、固定操作序列，实现“无论密钥位如何，执行相同操作”，从而抵抗时序攻击。

**1.3 Montgomery 阶梯标量乘法**：具有抵抗时序攻击的能力. 该算法非常规则，**无论密钥为何值**，其总是执行**相同的操作序列**，因而是**恒定时间**实现的。

```cpp
Montgomery 阶梯标量乘法
输入：基数 b，模数 m，指数 e = (e_{n-1}···e_0)
输出：b^e mod m

(r_0, r_1) = (b, b^2)             // 初始化两个变量，r_0 存储当前结果，r_1 存储辅助值
for i = n-1 downto 0 do           // 从最高位到最低位遍历指数 e 的每一位
    if e_i = 0 then                   // 如果当前指数位为 0
        (r_0, r_1) = (r_0^2, r_0 · r_1)   // 更新 r_0 为平方，r_1 为乘积
    else                              // 如果当前指数位为 1
        (r_0, r_1) = (r_0 · r_1, r_1^2)   // 更新 r_0 为乘积，r_1 为平方
    end if
end for
return R                        // 返回计算结果
```

**1.3.1 问题**：密码库在实现此算法时，所依赖的底层大数运算库（如`OpenSSL`中的BN库、`Libgcrypt`中的模运算函数）存在数据依赖性的优化或分支，破坏了整个算法链的恒定时间属性，从而为侧信道攻击打开了缺口。

**1.4 实现真正恒定时间的三个必备前提：**

1. **无数据依赖的内存访问**：算法的内存访问地址和模式不能依赖于密钥或敏感中间值，否则会通过缓存状态泄露信息。
2. **无数据依赖的算术操作序列**：算法必须执行完全固定数量、类型和顺序的域运算（如乘、加、平方），不受密钥位控制。
3. **底层函数的恒定时间属性**：算法所调用的**所有底层子函数（如模乘、模加、模约减、内存拷贝）** 本身也必须满足条件1和条件2，其执行时间必须与操作数的具体值绝对无关。

---

### 2. 能量分析攻击

**2.1 能量泄露模型**

![image-20251225153802244](assets/image-20251225153802244.png)

**2.2 原理：**

**2.2.1 加密设备（左边）：**

- **m**：已知的明文（比如攻击者故意输入的"123456"）
- **k**：正确密钥（保险箱的真正密码，**攻击者不知道**）
- **⊕**：异或操作（一种简单的二进制运算，不用管细节）
- **f( )**：泄漏函数（**计算能量迹的方法**）
  
  *举例*：f 可以是计算某个中间结果的"1的个数"（汉明重量），1越多，电流声越大

- **n**：噪声 ~ N(0, Σ)（环境杂音，比如其他电器干扰）

- **x**：攻击者实际采集到的能量迹

**2.2.2 攻击者（右边）：**

- **x**：攻击者实际采集到的能量迹

- **p(x | f(m⊕k))**：概率公式（**猜测是密钥k造成的可能性**）

- **argmax**：找最大值（**最大似然估计法，哪个密码k让概率最大，就猜哪个**）

- **k∈K**：遍历所有可能的密码

