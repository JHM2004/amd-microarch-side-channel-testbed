### 🎯 核心概念与前提
**Prime+Probe** 是一种 **“基于缓存组竞争的侧信道攻击”** 。它的核心思想是：攻击者通过监控**整个CPU缓存组**的占用和驱逐状态，来推断受害者进程的内存访问模式，而**不需要与受害者共享特定内存地址**。

理解此攻击，必须先了解两个关键硬件机制：
1.  **CPU缓存的组织结构**：现代CPU缓存采用 *组相联* 映射。主存地址被映射到特定的 **缓存组** ，每个组内有若干条 **缓存行** 。当缓存已满，新数据会按策略（如LRU）**驱逐** 旧数据。
2.  **访问时间差异**：访问已缓存的数据（命中）极快（~数纳秒），访问需从内存加载的数据（未命中）很慢（~数百纳秒）。

### ⚙️ **Prime+Probe** 工作原理与步骤
攻击者通过**精心选择的一组属于同一缓存组的内存地址**（称为 **“攻击者地址集”**）来实施攻击。

#### **步骤一：Prime（填充/占据）**
1.  **目标**：攻击者用自己的数据，**完全占据**目标缓存组的所有缓存行。
2.  **操作**：攻击者**顺序、反复地访问**其“攻击者地址集”中的每一个地址。这确保了这些地址的数据被加载到目标缓存组中，将该组内可能的原有数据（包括受害者留下的）**驱逐出去**。
3.  **结果**：此时，目标缓存组处于一个 **“已知状态”** ——完全被攻击者控制的数据占据。访问这些地址将非常快（全缓存命中）。

#### **步骤二：等待**
1. 攻击者**停止访问**，进入一个短暂的等待窗口。
2. 在此期间，**受害者进程开始执行**。如果受害者**访问了任何映射到同一目标缓存组的内存地址**，那么根据缓存替换策略（如LRU），受害者数据就会**将攻击者占据的部分或全部缓存行驱逐出去**。

#### **步骤三：Probe（探测/测量）**
1.  **目标**：测量目标缓存组的状态变化。
2.  **操作**：攻击者**再次顺序访问**其“攻击者地址集”中的每一个地址，并使用高精度计时器（如 `rdtsc`）**严格测量每次访问的耗时**。
3.  **关键分析**：
    *   **如果某个地址访问仍然很快**：说明攻击者的数据仍在缓存中，**受害者很可能没有访问过**这个缓存组。
    *   **如果某个地址访问突然变慢**：说明发生了**缓存未命中**，攻击者的数据被驱逐了。这**直接证明**受害者在该窗口内**访问了映射到此缓存组的某个地址**。

通过**持续、高频地重复“Prime-等待-Probe”循环**，并统计分析每次Probe阶段的时间延迟模式，攻击者就能构建出**受害者程序对内存的访问时间线**。结合对受害者代码或数据布局的逆向分析，即可推导出敏感信息（如加密算法的轮密钥、控制流路径等）。

### 🔄 与 **Flush+Reload** 的关键区别

| 特性                    | **Prime+Probe**                                              | **Flush+Reload**                                             |
| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **攻击对象**            | **整个缓存组**（粗粒度，监控一组地址）                       | **特定缓存行**（细粒度，监控单个地址）                       |
| **共享内存**            | **不需要**。攻击者使用自己的内存区域。                       | **必须要求** 攻击者与受害者共享目标物理内存页（如库文件）。  |
| **核心指令**            | 依赖普通的**内存加载**指令。                                 | 依赖特权指令 **`clflush`** 来清空缓存行。                    |
| **隐蔽性**              | 较低。会产生大量的缓存访问和驱逐，易被监控。                 | 较高。`clflush` 指令在非特权滥用时可能被检测。               |
| **在AMD平台上的适用性** | **适用性更广**。尤其在跨CCX场景下，由于不依赖跨核心的共享缓存一致性，只要能观测到自身缓存被驱逐，即可实施攻击。 | **受限**。传统方式在跨CCX时可能失效，需依赖如**内存总线争用**等间接通道（如Flush+Reload变种）。 |

### 🛡️ **Prime+Probe** 的防御思路
1.  **缓存分区与隔离**：硬件层面，如**Intel CAT**；或通过缓存着色等技术，为不同安全域分配独立的缓存区域。
2.  **恒定时间编程**：确保安全关键代码（如密码学算法）的执行路径和内存访问模式**不依赖于秘密数据**，使侧信道无信息可泄露。
3.  **增加噪声**：操作系统或Hypervisor随机化调度，或插入无关的缓存访问，干扰攻击者的计时测量。
4.  **监控与检测**：通过性能计数器监控异常的缓存未命中率或特定指令（如`clflush`）的滥用。

### 💎 总结
**Prime+Probe** 通过 **“占据-观测驱逐”** 的模式，将共享的CPU缓存资源转变为窃取信息的侧信道。它比Flush+Reload的适用条件更宽松（无需共享内存），但技术实现更复杂，需要对CPU缓存映射有深入了解。在AMD的CCX架构下，它成为跨核心、跨CCX攻击的重要技术基础。